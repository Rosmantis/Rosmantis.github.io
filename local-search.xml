<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于Hexo的本地博客搭建</title>
    <link href="/2022/01/09/Blog-Setup/"/>
    <url>/2022/01/09/Blog-Setup/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在21年下半年进实验室做了半年的科研训练，觉得应该适时地对自己的学习经历做阶段性总结，既可以用来复习回顾，又可以形成一种正反馈的成就机制，于是决定搭建一个自己的博客。网络上已经有一些非常详细的教程，本文也参照了这些教程，不过考虑到日后重建的需要，还是自己再做一遍总结比较妥当。日后的个性化定制、写作、服务器部署等等之后会写在其他文章里作为补充。</p><p>本博客搭建使用 Hexo 框架，它是基于 Node.js 的高效静态站点生成框架。通过 Hexo，可以使用 Markdown 语法来撰写文章，再生成静态网站并部署到本地或者服务器端。因此我们可以专注于写作的内容，不需要担心网页源代码的具体细节。</p><h2 id="安装">安装</h2><p>需要安装的内容包括：</p><ul><li>Node.js (版本需不低于10.13，建议使用Node.js 12.0以上版本)</li><li>Git</li><li>Hexo (前两项是安装Hexo的必要条件)</li></ul><h3 id="node.js安装">Node.js安装</h3><p>首先在官网上下载 <a href="https://nodejs.org/en/">Node.js</a>，版本根据自己喜好选择，下载后安装，安装选项随意。</p><p><strong>安装验证方法：</strong></p><p>cmd 窗口内输入 <code>node -v</code> 和 <code>npm -v</code>，如果出现版本号，那么安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 本机示例</span><br>C:\Users\Pand&gt;node -v<br>v14.16.1<br><br>C:\Users\Pand&gt;npm -v<br>6.14.12<br></code></pre></td></tr></table></figure><h4 id="国内镜像源加速">国内镜像源加速</h4><p>如果没有梯子，npm 下载速度可能会很慢，可以设置国内镜像源进行加速。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>查看 config 使用 <code>npm config list</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 本机示例</span><br>C:\Users\Pand&gt;npm config list<br>; cli configs<br>metrics-registry = <span class="hljs-string">&quot;https://registry.npm.taobao.org/&quot;</span><br>scope = <span class="hljs-string">&quot;&quot;</span><br>user-agent = <span class="hljs-string">&quot;npm/6.14.12 node/v14.16.1 win32 x64&quot;</span><br><br>; userconfig C:\Users\Pand\.npmrc<br>registry = <span class="hljs-string">&quot;https://registry.npm.taobao.org/&quot;</span> <span class="hljs-comment"># 此行说明已经配置成功</span><br><br>; <span class="hljs-built_in">builtin</span> config undefined<br>prefix = <span class="hljs-string">&quot;C:\\Users\\Pand\\AppData\\Roaming\\npm&quot;</span><br><br>; node bin location = C:\Program Files\nodejs\node.exe<br>; cwd = C:\Users\Pand<br>; HOME = C:\Users\Pand<br>; <span class="hljs-string">&quot;npm config ls -l&quot;</span> to show all defaults.<br></code></pre></td></tr></table></figure><h3 id="git安装">Git安装</h3><p>Hexo 需要通过 Git 进行版本控制，因此还要下载 Git，此处给出两个下载地址，下载后安装，安装选项随意。</p><ul><li><a href="https://npm.taobao.org/mirrors/git-for-windows/">淘宝 Git for Windows 镜像</a></li><li><a href="https://git-scm.com/download/win">官方下载地址</a></li></ul><p><strong>安装验证方法：</strong></p><p>cmd 窗口内输入 <code>git --version</code>，如果出现版本号，那么安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\Pand&gt;git --version<br>git version 2.32.0.windows.2<br></code></pre></td></tr></table></figure><h3 id="hexo安装">Hexo安装</h3><p>在完成前两项安装之后，可使用 npm 安装 Hexo。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p><strong>安装验证方法：</strong></p><p>cmd 窗口内输入 <code>hexo -v</code>，出现版本信息，那么安装成功。</p><h2 id="配置">配置</h2><p>安装 Hexo 完成后，新建一个文件夹作为博客文件夹，之后运行以下命令来新建网站：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init folder <span class="hljs-comment"># 此处folder为新建文件夹名称</span><br><span class="hljs-built_in">cd</span> folder<br>npm install<br></code></pre></td></tr></table></figure><p>新建完成后，博客文件夹的目录如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">.<br>├── <span class="hljs-variable">_config</span>.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── <span class="hljs-variable">_drafts</span><br>|   └── <span class="hljs-variable">_posts</span><br>└── themes<br></code></pre></td></tr></table></figure><p>下面介绍该目录下的文件，根据自己需求修改，进一步完成博客配置。</p><h3 id="config.yml">_config.yml</h3><p>主配置文件，可以在 <code>_config.yml</code> 中修改大部分配置，文件中重要参数及其作用如下。</p><table><thead><tr class="header"><th>参数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>title</code></td><td>网站标题</td></tr><tr class="even"><td><code>subtitle</code></td><td>网站副标题</td></tr><tr class="odd"><td><code>description</code></td><td>网站描述，用于搜索引擎检索</td></tr><tr class="even"><td><code>keywords</code></td><td>网站关键词，用于搜索引擎检索</td></tr><tr class="odd"><td><code>author</code></td><td>作者名</td></tr><tr class="even"><td><code>language</code></td><td>网站使用的语言。中文 <code>zh-CN</code>，英文<code>en</code></td></tr><tr class="odd"><td><code>timezone</code></td><td>网站时区。参照 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，中国大陆地区可以使用 <code>Asia/Shanghai</code></td></tr><tr class="even"><td><code>url</code></td><td>网址，必须以 <code>http://</code> 或 <code>https://</code> 开头</td></tr><tr class="odd"><td><code>root</code></td><td>网站根目录</td></tr><tr class="even"><td><code>source_dir</code></td><td>资源文件夹，用来存放博客源文件</td></tr><tr class="odd"><td><code>public_dir</code></td><td>公共文件夹，用于存放生成的站点文件</td></tr><tr class="even"><td><code>tag_dir</code></td><td>标签文件夹</td></tr><tr class="odd"><td><code>archive_dir</code></td><td>归档文件夹</td></tr><tr class="even"><td><code>category_dir</code></td><td>分类文件夹</td></tr><tr class="odd"><td><code>theme</code></td><td>当前主题名称</td></tr></tbody></table><h3 id="scaffolds">scaffolds</h3><p>模板文件夹。新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>scaffolds下 draft 是新建草稿模板，post 是新建文章模板，page 是新建页面模板。</p><p>下面是我使用的 scaffold-post 示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">title: &#123;&#123; title &#125;&#125;<br>date: &#123;&#123; date &#125;&#125;<br>categories: <br>tags: <br>excerpt: <br>index<span class="hljs-emphasis">_img: </span><br></code></pre></td></tr></table></figure><h3 id="source">source</h3><p>用户资源文件夹。除 <code>_post</code> 文件夹外，开头命名为 <code>_</code> 的文件/文件夹将被忽略。</p><p>Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，其他文件会被拷贝过去。</p><h3 id="theme">theme</h3><p>主题文件夹。Hexo 会根据主题来生成静态页面。</p><p>可以在 <a href="https://hexo.io/themes/">Hexo 主题官网</a> 找到自己想要的主题并安装。一般来讲，安装主题直接下载主题包并复制到 <code>theme</code> 文件夹即可。</p><p>如果主题有 Github 仓库，可以直接在主题文件夹内执行 <code>git clone 'Github网址'</code> 下载主题仓库，并在<code>_config.yml</code> 文件中修改主题名称。</p><p>本博客采用的是 <code>Fluid</code> 主题，个人觉得比较好看、简洁，其相关链接如下</p><ul><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">Github 仓库</a></li><li><a href="https://hexo.fluid-dev.com/">Fluid Demo</a></li></ul><h2 id="参考">参考</h2><ul><li>[1] <a href="https://godweiyang.com/2018/04/13/hexo-blog/">超详细Hexo+Github博客搭建小白教程</a></li><li>[2] <a href="https://zhuanlan.zhihu.com/p/28329874">Hexo与Github搭建个人博客</a></li><li>[3] <a href="https://hsinjhao.github.io/2019/05/16/BuildBlogsBasedOnHexoAndGithub/">利用hexo和github搭建个人博客的辛酸之路</a></li><li>[4] <a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Blog Building</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>t-Distributed Stochastic Neighbor Embedding (t-SNE)</title>
    <link href="/2022/01/05/t-SNE%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/01/05/t-SNE%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p><strong>t-distributed stochastic neighbor embedding (t-SNE)</strong><a href="#refer-anchor-1"><sup>[1]<sup></a> 是一种基于概率将高维数据降为低维的降维方法，通常被用于将高维数据进行2维或3维的可视化。</p><p>传统的<strong>线性方法</strong>主要将<strong>不相似的点</strong>在低维表示中分开。</p><blockquote><p>PCA (Principle Components Analysis, 主成分分析)</p><p>MDS (Multiple Dimensional Scaling, 多维缩放)</p></blockquote><p>对处于<strong>低维流形</strong>上的高维数据而言，更重要地是让<strong>相邻点</strong>在低维表示中保持相邻。<strong>非线性技术</strong>主要保持数据的<strong>局部结构</strong> (Locality)。</p><blockquote><p>Sammon mapping</p><p>LLE (Locally Linear Embedding, 局部线性嵌入)</p><p>LE (Laplacian Eigenmaps, 拉普拉斯特征映射)</p><p>Isomap (Isometric Mapping, 等度量映射)</p></blockquote><p>和以上方法相同，<strong>t-SNE</strong>通过建立<strong>配对相似度</strong> (pairwise similarities)来进行低维重构。</p><p>不同的是，<strong>t-SNE</strong>通过概率来建立配对相似度，而不是简单地通过距离建立。</p><p>首先我们先介绍t-SNE的前身，SNE (Stochastic Neighbor Embedding, 随机近邻嵌入)</p><h2 id="sne">SNE</h2><p>SNE首先通过概率来建立配对相似度。</p><h4 id="配对相似度-基于条件概率">配对相似度-基于条件概率</h4><p>给定一组高维数据点<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>，<span class="math inline">\(p_{j|i}\)</span>是<span class="math inline">\(x_i\)</span>会将<span class="math inline">\(x_j\)</span>选为邻居的条件概率。这里的比值是邻居和所有点的高斯分布概率密度之比。 <span class="math display">\[p_{j|i}=\frac{exp(-||x_i-x_j||^2/2\sigma_i^2)}{\sum\limits_{k\neq i}exp(-||x_i-x_k||^2/2\sigma_i^2)}\]</span> 注意：1）分母即归一化。2）默认<span class="math inline">\(p_{i|i}=0\)</span>。3）每不同数据点<span class="math inline">\(x_i\)</span>有不同的<span class="math inline">\(\sigma_i\)</span>。其计算方式将在下面叙述。</p><p>同样的，对于低维表示，定义同样的条件概率。不同的是，为了消除缩放对数据点的影响，同时也为了方便计算，这里指定<span class="math inline">\(\sigma_i = \frac{1}{\sqrt{2}}\)</span>。 <span class="math display">\[q_{j|i}=\frac{exp(-||y_i-y_j||^2)}{\sum\limits_{k\neq i}exp(-||y_i-y_k||^2)}\]</span> 注意：1）若<span class="math inline">\(\sigma_i\)</span>取其他值，也只影响缩放。</p><p>则可以认为，如果建模正确，低维映射<span class="math inline">\(y_i\)</span>和<span class="math inline">\(y_j\)</span>的相似度应该和高维数据<span class="math inline">\(x_i\)</span>和<span class="math inline">\(x_j\)</span>的相似度相等。</p><h4 id="损失函数-基于kl散度">损失函数-基于KL散度</h4><p>基于这个想法，SNE意图找到一个可以减小<span class="math inline">\(p_{j|i}\)</span>和<span class="math inline">\(q_{j|i}\)</span>之间失配 (mismatch) 的低维表示。</p><p>为了减少失配，首先需要方法来衡量它，SNE引入了<a href="#kl散度">KL散度</a> (Kullback-Leibler divergences)<a href="#refer-anchor-2"><sup>[2]<sup></a> 来衡量失配，损失函数 (cost function) 如下： <span class="math display">\[C=\sum\limits_i KL(P_i||Q_i)=\sum\limits_i\sum\limits_j p_{j|i}\log \frac{p_{j|i}}{q_{j|i}}\]</span> 定义了<span class="math inline">\(C\)</span>后，SNE采用梯度下降的方法来学习到合适的<span class="math inline">\(y_i\)</span>，对<span class="math inline">\(y_i\)</span>的梯度为： <span class="math display">\[\frac{\partial C}{\partial y_i}=2\sum\limits_j(p_{j|i}-q_{j|i}+p_{i|j}-q_{i|j})(y_i-y_j)\]</span> 采用动量项来迭代更新<span class="math inline">\(y_i\)</span> <span class="math display">\[y_i^{(t)}=y_i^{(t-1)}+\eta \frac{\partial C}{\partial y_i}+\alpha(t)(y_i^{(t-1)}-y_i^{(t-2)})\]</span> 至此，SNE的过程已经介绍完毕，通过计算条件概率来得到<span class="math inline">\(P\)</span>，初始化<span class="math inline">\(Y\)</span>后，计算<span class="math inline">\(Q\)</span>。之后通过动量梯度下降来更新<span class="math inline">\(Y\)</span>，得到计算结果。</p><h4 id="选取sigma_i-基于熵">选取<span class="math inline">\(\sigma_i\)</span>-基于熵</h4><p>在数据集中，不同类别数据点的分布密度往往不同，因此不能定制一个所有点都适用的<span class="math inline">\(\sigma\)</span>。</p><blockquote><p>Every <span class="math inline">\(\sigma_i\)</span> is either set by hand or found by a simple binary search (<a href="#refer-anchor-3">Hinton and Roweis, 2003</a>) or by a very robust root-finding method (<a href="#refer-anchor-4">Vladymyrov and Carreira-Perpinan, 2013</a>)</p></blockquote><p>这里介绍一种基于熵来限制分布自由度的方法。</p><p>熵增加，<span class="math inline">\(\sigma_i\)</span>也增加，所以通过限制熵的大小来寻找合适的<span class="math inline">\(\sigma_i\)</span>，让不同类别的数据点有一个大致相同的分布。定义困惑度 (perplexity) 如下 <span class="math display">\[Perp(P_i) =2^{H(P_i)}=2^{-\sum\limits_jp_{j|i}\log_2p_{j|i}}\]</span> 这里的<span class="math inline">\(H(P_i)\)</span>是香农熵，通常指定的困惑值在5和50之间。</p><p>由于<span class="math inline">\(Perp(\cdot)\)</span>函数是单调函数，可以采用二分的方法来寻找<span class="math inline">\(\sigma_i\)</span>。</p><h4 id="sne局限-limitations">SNE局限 (Limitations)</h4><ul><li>Cost function 难以优化。偏导 <span class="math inline">\(2\sum\limits_j(p_{j|i}-q_{j|i}+p_{i|j}-q_{i|j})(y_i-y_j)\)</span> 难以计算。</li><li>Crowding problem。在二维映射空间中，能容纳<strong>（高维空间中的）中等距离间隔点</strong>的空间，不会比能容纳<strong>（高维空间中的）相近点</strong>的空间大太多。所以高维空间中离得远的、近的点，在低维空间中都被塞在了一起，引起了拥挤问题。</li></ul><h2 id="t-sne">t-SNE</h2><p>t-SNE在SNE的基础上进行了改进，优化了SNE的Limitations。</p><ul><li>Cost function 难以优化 <span class="math inline">\(\Longrightarrow\)</span> 使用 Symmetric SNE。</li><li>Crowding problem <span class="math inline">\(\Longrightarrow\)</span> 在低维嵌入上使用Student's t-distribution 替代 Guassian distribution，同时也简化了cost function。</li></ul><p>下面，我们将分别针对这些优化进行介绍。</p><h4 id="symmetric-sne">Symmetric SNE</h4><p>在高维空间中定义联合概率<span class="math inline">\(p_{ij}\)</span>为对称条件概率： <span class="math display">\[p_{ij}=\frac{p_{j|i}+p_{i|j}}{2n}\]</span> 则cost function为： <span class="math display">\[C=KL(P||Q)=\sum\limits_i\sum\limits_jp_{ij}\log\frac{p_{ij}}{q_{ij}}\]</span> 则简化后的偏导为： <span class="math display">\[\frac{\partial C}{\partial y_i}=4\sum\limits_j(p_{ij}-q_{ij})(y_i-y_j)\]</span> 偏导形式相对SNE来说更简单，计算速度更快。</p><p>(注意：这只是Symmetric SNE的梯度公式，t-SNE的梯度公式类似，推导见后。)</p><h4 id="crowding-problem">Crowding problem</h4><p>"crowding problem":</p><blockquote><p>The area of the two-dimensional map that is available to accommodate <strong>moderately distant datapoints</strong> will not be nearly large enough compared with the area available to accommodate <strong>nearby datapoints</strong>.</p></blockquote><p>在<a href="#sne局限%20(limitations)">SNE局限</a>中已经提到过，由于在低维空间中，能容纳的点一定比高维空间中的少，所以高维空间中远的、近的点，在低维空间中往往被塞在一起。</p><p>这个问题其实是由于高斯概率分布造成的，高斯分布对于中等距离和较近距离的区分较少，也即，不能对近距离的点做出明显区分。因此，对于低维表示，t-SNE采用t分布来替换高斯分布。</p><p><img src="gaussian_t_comparasion.png" style="zoom:72%;" /></p><p>上图横轴表示距离，纵轴表示相似度，可以看到，对较大相似度的点，t分布在低维空间中的距离需要更小一点，对于低相似度的点，t分布在低维空间中需要的距离更远。</p><p>所以，可以使同一簇内的点聚合地更紧密，不同簇之间的点更加疏远，解决crowding problem。</p><h4 id="t-sne配对相似度及损失函数">t-SNE配对相似度及损失函数</h4><p>至此为止，我们可以定义联结概率 (joint probabilities) <span class="math inline">\(q_{ij}\)</span>： <span class="math display">\[q_{ij}=\frac{(1+||y_i-y_j||^2)^{-1}}{\sum\limits_{k\neq l}(1+||y_k-y_l||^2)^{-1}}\]</span> 注意：和SNE的<span class="math inline">\(q_{j|i}\)</span>公式相比，分母的求和号中，之前是<span class="math inline">\(k\neq i\)</span>，表示仅排除 <span class="math inline">\(i\)</span> 自身项；现在是 <span class="math inline">\(k\neq l\)</span> ，表示排除所有自身项。也就是点对间所有两两之差。</p><p>损失函数 (cost function) 为： <span class="math display">\[\frac{\partial C}{\partial y_i}=4\sum\limits_j(p_{ij}-q_{ij})(y_i-y_j)(1+||y_i-y_j||^2)^{-1}\]</span></p><p>推导详见 Maaten &amp; Hinton, 2008<a href="#refer-anchor-7"><sup>[4]<sup></a> Appendix A.</p><p>至此，我们已经得到了t-SNE的损失函数，可以同样通过SNE中提到的动量迭代法来求解<span class="math inline">\(Y\)</span>。</p><p>接下来，对t-SNE的优势和局限性做一个总结。</p><h2 id="优势及局限性">优势及局限性</h2><p>Advantages：</p><ul><li>相较于LLE和LE等算法来说，t-SNE中点的相似度 (similarity) 由概率密度表示，不用KNN指定邻居，减少了参数量。</li><li>每个点的局部邻居由概率密度表示，具有适应性 (相当于可以对每个点自定义邻居数量)。</li><li>高维数据中高斯密度的应用让t-SNE保有局部特征的同时，维护全局结构。(不太懂)</li></ul><blockquote><p>Gaussian kernel employed by t-SNE (in high-dimensional) defines a soft border between the local and global structure of the data.</p></blockquote><ul><li>相较于SNE，t-SNE采用t分布后消除了一部分指数计算，计算效率更高，计算更快。</li></ul><p>Limitations：</p><ul><li>t-SNE不一定适用于超过三维的降维。对于超过三维的更高维度，t分布可能需要采用更高的自由度才更加合适。</li></ul><blockquote><p>It is unclear t-SNE would perform on general <strong>Dimensionality Reduction</strong> for more than 3 dimensions. For such higher (than 3) dimensions, Student-t distribution with more degrees of freedom should be more appropriate.</p></blockquote><ul><li>t-SNE也是通过数据的局部结构来执行降维任务的，因此可能对某些高维数据失效 (数据本身就是高维的，无法找到一种恰当的低维表示)</li></ul><blockquote><p>t-SNE reduces the dimensionality of data mainly based on local properties of the data which means it would fail in data which has intrinsically high dimensional structure (<strong>curse of dimensionality</strong>).</p></blockquote><ul><li>t-SNE的损失函数不是凸函数，因此在构造解的时候不会有固定解，而且没有一种有效且固定的解法，只能通过迭代求解。</li></ul><h2 id="关联概念">关联概念</h2><h3 id="kl散度">KL散度</h3><p>上文中提到的KL散度是一种衡量概率差别的方法，是两个概率分布<span class="math inline">\(P\)</span>和<span class="math inline">\(Q\)</span>差别的<strong>非对称</strong>度量。</p><blockquote><p>KL散度 (Kullback-Leibler divergence，简称KLD)，在讯息系统中称为相对熵 (relative entropy)<a href="#refer-anchor-2"><sup>[2]<sup></a>。</p></blockquote><h4 id="定义">定义</h4><p>对于离散随机变量，它的概率分布<span class="math inline">\(P\)</span>和<span class="math inline">\(Q\)</span>的KL散度可按下式定义为 <span class="math display">\[D_{KL}(P||Q)=\sum\limits_iP(i)\ln\frac{P(i)}{Q(i)}\]</span> 即按概率<span class="math inline">\(P\)</span>求得的<span class="math inline">\(P\)</span>和<span class="math inline">\(Q\)</span>的对数商的平均值。KL散度仅当概率<span class="math inline">\(P\)</span>和<span class="math inline">\(Q\)</span>各自总和均为1，且对于任何<span class="math inline">\(i\)</span>皆满足<span class="math inline">\(Q(i)&gt;0\)</span>以及<span class="math inline">\(P(i)&gt;0\)</span>时才有定义。</p><h4 id="特性">特性</h4><p>KLD的值为非负数： <span class="math display">\[D_{KL}(P||Q)\ge 0\]</span> 当且仅当<span class="math inline">\(P=Q\)</span>时<span class="math inline">\(D_{KL}(P||Q)\)</span>为零。</p><p>虽然从直觉上KL散度是个度量或距离函数，但是它实际上并不是一个真正的度量或距离。因为KL散度具有不对称性： <span class="math display">\[D_{KL}(P||Q)\neq D_{KL}(Q||P)\]</span></p><h3 id="students-t-distribution">Student's t-distribution</h3><p><strong>学生t分布</strong> (Student's t-distribution)，简称<strong>t分布</strong>，在概率论及统计学中用于根据小样本来估计总体呈正态分布且标准差未知的期望值<a href="#refer-anchor-6"><sup>[3]<sup></a>。</p><p>其概率分布密度函数 (Probability Density Function, PDF) 为 <span class="math display">\[f(t)=\frac{\Gamma(\frac{v+1}{2})}{\sqrt{v\pi}\Gamma(\frac{v}{2})}(1+\frac{t^2}{v})^{-\frac{v+1}{2}}\]</span> 其中 <span class="math inline">\(v\)</span> 是自由度 。</p><p>特殊情况，当 <span class="math inline">\(v=1\)</span> 时 <span class="math display">\[f(t)=\frac{1}{\pi(1+t^2)}\]</span> 这种概率分布也叫作柯西分布 (Cauchy distribution)。在t-SNE中用到的也是柯西分布。</p><p>特殊情况，当 <span class="math inline">\(v=\infty\)</span> 时 <span class="math display">\[f(t)=\frac{1}{\sqrt{2\pi}}e^{-\frac{t^2}{2}}\]</span> 称为高斯/正态分布。</p><p>t分布的概率密度图如下图所示。</p><p><img src="student_t_pdf.png" alt="Student's t-distribution" style="zoom:30%;" /></p><h2 id="引用">引用</h2><div id="refer-anchor-1"><div><ul><li>[1] <a href="https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding">Wikipedia: t-distributed stochastic neighbor embedding</a></li></ul><div id="refer-anchor-2"><div><ul><li>[2] <a href="https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence">Wikipedia: Kullback–Leibler divergence</a></li></ul><div id="refer-anchor-6"><div><ul><li>[3] <a href="https://en.wikipedia.org/wiki/Student%27s_t-distribution">Wikipedia: Student's t-distribution</a></li></ul><div id="refer-anchor-7"><div><ul><li>[4] Van der Maaten L, Hinton G. Visualizing data using t-SNE[J]. Journal of machine learning research, 2008, 9(11).</li></ul><h2 id="参考文献">参考文献</h2><div id="refer-anchor-3"><div><ul><li>[1] Hinton G, Roweis S T. Stochastic neighbor embedding[C]//NIPS. 2002, 15: 833-840.</li></ul><div id="refer-anchor-4"><div><ul><li>[2] Vladymyrov M, Carreira-Perpinan M. Entropic affinities: Properties and efficient numerical computation[C]//International conference on machine learning. PMLR, 2013: 477-485.</li></ul><div id="refer-anchor-5"><div><ul><li>[3] <a href="https://psubnwell.github.io/2017/12/01/paper-note-t-sne/">论文笔记：Visualizing data using t-SNE</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Representation Learning</category>
      
      <category>Dimension Reduction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>t-SNE</tag>
      
      <tag>Dimension Reduction</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github_v2ray</title>
    <link href="/2021/12/29/github-v2ray/"/>
    <url>/2021/12/29/github-v2ray/</url>
    
    <content type="html"><![CDATA[<h3 id="github设置代理"><a href="#github设置代理" class="headerlink" title="github设置代理"></a>github设置代理</h3><p>由于git clone速度过慢，只有几十KiB，网上改host的教程也完全不管用。</p><p>查询之后发现git clone不走系统代理端口，即使本地科学上网也没有用。</p><p>所以需要对git进行全局配置</p><h3 id="v2Ray"><a href="#v2Ray" class="headerlink" title="v2Ray"></a>v2Ray</h3><p>v2Ray已经配置好，可以科学上网</p><h4 id="v2Ray侦听端口"><a href="#v2Ray侦听端口" class="headerlink" title="v2Ray侦听端口"></a>v2Ray侦听端口</h4><p>可以在v2Ray客户端下方看到</p><p>本地ip地址为<code>127.0.0.1</code>，此处socks侦听端口为10808，http侦听端口为10809</p><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><ul><li><code>git config --global http.proxy http://127.0.0.1:10809</code></li><li><code>git config --global http.proxy socks5://127.0.0.1:10808</code></li></ul><h3 id="查看代理"><a href="#查看代理" class="headerlink" title="查看代理"></a>查看代理</h3><p>查看所有全局配置 <code>git config -l</code></p><p>查看全局http代理配置 <code>git config --global --get-regexp http.*</code></p><h3 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h3><p>取消全局代理 <code>git config --global --unset **http.proxy**</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>subplot</title>
    <link href="/2021/12/29/subplot/"/>
    <url>/2021/12/29/subplot/</url>
    
    <content type="html"><![CDATA[<h3 id="pyplot-绘制多图方法"><a href="#pyplot-绘制多图方法" class="headerlink" title="pyplot 绘制多图方法"></a>pyplot 绘制多图方法</h3><hr><h4 id="subplot"><a href="#subplot" class="headerlink" title="subplot"></a>subplot</h4><h5 id="subplot-语法："><a href="#subplot-语法：" class="headerlink" title="subplot()语法："></a>subplot()语法：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">subplot(nrows, ncols, index, **kwargs)<br></code></pre></td></tr></table></figure><ul><li>nrows：行数</li><li>ncols：列数</li><li>index：从左到右，从上到下，每个子区域的编号$1\cdots N$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">row, col = <span class="hljs-number">3</span>, <span class="hljs-number">2</span><br><br>img = img.reshape(features, samples)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, row * col+<span class="hljs-number">1</span>):<br>    plt.subplot(row, col, i)<br>    timg = img[:, i-<span class="hljs-number">1</span>]<br>    timg = timg.reshape(width, height)<br>    plt.imshow(timg)<br>    plt.xticks([])<br>    plt.yticks([])<br>plt.show()<br></code></pre></td></tr></table></figure><h4 id="subplots"><a href="#subplots" class="headerlink" title="subplots"></a>subplots</h4><h5 id="subplots-语法："><a href="#subplots-语法：" class="headerlink" title="subplots()语法："></a>subplots()语法：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">matplotlib.pyplot.subplots(nrows=<span class="hljs-number">1</span>, ncols=<span class="hljs-number">1</span>, *, sharex=<span class="hljs-literal">False</span>, sharey=<span class="hljs-literal">False</span>, squeeze=<span class="hljs-literal">True</span>, subplot_kw=<span class="hljs-literal">None</span>, gridspec_kw=<span class="hljs-literal">None</span>, **fig_kw)<br></code></pre></td></tr></table></figure><ul><li><strong>nrows</strong>：默认为 1，设置图表的行数。</li><li><strong>ncols</strong>：默认为 1，设置图表的列数。</li><li><strong>sharex、sharey</strong>：设置 x、y 轴是否共享属性，默认为 false，可设置为 ‘none’、’all’、’row’ 或 ‘col’。 False 或 none 每个子图的 x 轴或 y 轴都是独立的，True 或 ‘all’：所有子图共享 x 轴或 y 轴，’row’ 设置每个子图行共享一个 x 轴或 y 轴，’col’：设置每个子图列共享一个 x 轴或 y 轴。</li><li><strong>squeeze</strong>：布尔值，默认为 True，表示额外的维度从返回的 Axes(轴)对象中挤出，对于 N<em>1 或 1</em>N 个子图，返回一个 1 维数组，对于 N*M，N&gt;1 和 M&gt;1 返回一个 2 维数组。如果设置为 False，则不进行挤压操作，返回一个元素为 Axes 实例的2维数组，即使它最终是1x1。</li><li><strong>subplot_kw</strong>：可选，字典类型。把字典的关键字传递给 add_subplot() 来创建每个子图。</li><li><strong>gridspec_kw</strong>：可选，字典类型。把字典的关键字传递给 GridSpec 构造函数创建子图放在网格里(grid)</li><li>*<strong>*fig_kw</strong>：把详细的关键字参数传给 figure() 函数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建画像和子图</span><br>fig, axs = plt.subplots(nrows, ncols)<br><br><span class="hljs-comment">###### 未对代码进行测试！</span><br>axs[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>].imshow(timg1)<br>axs[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>].axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br>axs[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>].imshow(timg2)<br>axs[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>].axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br><span class="hljs-comment">######</span><br>fig.show()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
